{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.InvalidStatusCodeError = exports.InvalidCertError = void 0;\nconst DEFAULT_OPT = Object.freeze({\n  redirect: true,\n  expectStatusCode: 200,\n  headers: {},\n  full: false,\n  keepAlive: true,\n  cors: false,\n  referrer: false,\n  sslAllowSelfSigned: false,\n  _redirectCount: 0\n});\nclass InvalidCertError extends Error {\n  constructor(msg, fingerprint256) {\n    super(msg);\n    this.fingerprint256 = fingerprint256;\n  }\n}\nexports.InvalidCertError = InvalidCertError;\nclass InvalidStatusCodeError extends Error {\n  constructor(statusCode) {\n    super(\"Request Failed. Status Code: \".concat(statusCode));\n    this.statusCode = statusCode;\n  }\n}\nexports.InvalidStatusCodeError = InvalidStatusCodeError;\nfunction detectType(b, type) {\n  if (!type || type === 'text' || type === 'json') {\n    try {\n      let text = new TextDecoder('utf8', {\n        fatal: true\n      }).decode(b);\n      if (type === 'text') return text;\n      try {\n        return JSON.parse(text);\n      } catch (err) {\n        if (type === 'json') throw err;\n        return text;\n      }\n    } catch (err) {\n      if (type === 'text' || type === 'json') throw err;\n    }\n  }\n  return b;\n}\nlet agents = {};\nfunction fetchNode(url, _options) {\n  let options = {\n    ...DEFAULT_OPT,\n    ..._options\n  };\n  const http = require('http');\n  const https = require('https');\n  const zlib = require('zlib');\n  const {\n    promisify\n  } = require('util');\n  const {\n    resolve: urlResolve\n  } = require('url');\n  const isSecure = !!/^https/.test(url);\n  let opts = {\n    method: options.method || 'GET',\n    headers: {\n      'Accept-Encoding': 'gzip, deflate, br'\n    }\n  };\n  const compactFP = s => s.replace(/:| /g, '').toLowerCase();\n  if (options.keepAlive) {\n    var _options$sslPinnedCer;\n    const agentOpt = {\n      keepAlive: true,\n      keepAliveMsecs: 30 * 1000,\n      maxFreeSockets: 1024,\n      maxCachedSessions: 1024\n    };\n    const agentKey = [isSecure, isSecure && ((_options$sslPinnedCer = options.sslPinnedCertificates) === null || _options$sslPinnedCer === void 0 ? void 0 : _options$sslPinnedCer.map(i => compactFP(i)).sort())].join();\n    opts.agent = agents[agentKey] || (agents[agentKey] = new (isSecure ? https : http).Agent(agentOpt));\n  }\n  if (options.type === 'json') opts.headers['Content-Type'] = 'application/json';\n  if (options.data) {\n    if (!options.method) opts.method = 'POST';\n    opts.body = options.type === 'json' ? JSON.stringify(options.data) : options.data;\n  }\n  opts.headers = {\n    ...opts.headers,\n    ...options.headers\n  };\n  if (options.sslAllowSelfSigned) opts.rejectUnauthorized = false;\n  const handleRes = async res => {\n    const status = res.statusCode;\n    if (options.redirect && 300 <= status && status < 400 && res.headers['location']) {\n      if (options._redirectCount == 10) throw new Error('Request failed. Too much redirects.');\n      options._redirectCount += 1;\n      return await fetchNode(urlResolve(url, res.headers['location']), options);\n    }\n    if (options.expectStatusCode && status !== options.expectStatusCode) {\n      res.resume();\n      throw new InvalidStatusCodeError(status);\n    }\n    let buf = [];\n    for await (const chunk of res) buf.push(chunk);\n    let bytes = Buffer.concat(buf);\n    const encoding = res.headers['content-encoding'];\n    if (encoding === 'br') bytes = await promisify(zlib.brotliDecompress)(bytes);\n    if (encoding === 'gzip' || encoding === 'deflate') bytes = await promisify(zlib.unzip)(bytes);\n    const body = detectType(bytes, options.type);\n    if (options.full) return {\n      headers: res.headers,\n      status,\n      body\n    };\n    return body;\n  };\n  return new Promise((resolve, reject) => {\n    var _options$sslPinnedCer2;\n    const handleError = async err => {\n      if (err && err.code === 'DEPTH_ZERO_SELF_SIGNED_CERT') {\n        try {\n          await fetchNode(url, {\n            ...options,\n            sslAllowSelfSigned: true,\n            sslPinnedCertificates: []\n          });\n        } catch (e) {\n          if (e && e.fingerprint256) {\n            err = new InvalidCertError(\"Self-signed SSL certificate: \".concat(e.fingerprint256), e.fingerprint256);\n          }\n        }\n      }\n      reject(err);\n    };\n    const req = (isSecure ? https : http).request(url, opts, res => {\n      res.on('error', handleError);\n      (async () => {\n        try {\n          resolve(await handleRes(res));\n        } catch (error) {\n          reject(error);\n        }\n      })();\n    });\n    req.on('error', handleError);\n    const pinned = (_options$sslPinnedCer2 = options.sslPinnedCertificates) === null || _options$sslPinnedCer2 === void 0 ? void 0 : _options$sslPinnedCer2.map(i => compactFP(i));\n    const mfetchSecureConnect = socket => {\n      var _socket$getPeerCertif;\n      const fp256 = compactFP(((_socket$getPeerCertif = socket.getPeerCertificate()) === null || _socket$getPeerCertif === void 0 ? void 0 : _socket$getPeerCertif.fingerprint256) || '');\n      if (!fp256 && socket.isSessionReused()) return;\n      if (pinned.includes(fp256)) return;\n      req.emit('error', new InvalidCertError(\"Invalid SSL certificate: \".concat(fp256, \" Expected: \").concat(pinned), fp256));\n      return req.abort();\n    };\n    if (options.sslPinnedCertificates) {\n      req.on('socket', socket => {\n        const hasListeners = socket.listeners('secureConnect').map(i => (i.name || '').replace('bound ', '')).includes('mfetchSecureConnect');\n        if (hasListeners) return;\n        socket.on('secureConnect', mfetchSecureConnect.bind(null, socket));\n      });\n    }\n    if (options.keepAlive) req.setNoDelay(true);\n    if (opts.body) req.write(opts.body);\n    req.end();\n  });\n}\nconst SAFE_HEADERS = new Set(['Accept', 'Accept-Language', 'Content-Language', 'Content-Type'].map(i => i.toLowerCase()));\nconst FORBIDDEN_HEADERS = new Set(['Accept-Charset', 'Accept-Encoding', 'Access-Control-Request-Headers', 'Access-Control-Request-Method', 'Connection', 'Content-Length', 'Cookie', 'Cookie2', 'Date', 'DNT', 'Expect', 'Host', 'Keep-Alive', 'Origin', 'Referer', 'TE', 'Trailer', 'Transfer-Encoding', 'Upgrade', 'Via'].map(i => i.toLowerCase()));\nasync function fetchBrowser(url, _options) {\n  let options = {\n    ...DEFAULT_OPT,\n    ..._options\n  };\n  const headers = new Headers();\n  if (options.type === 'json') headers.set('Content-Type', 'application/json');\n  let parsed = new URL(url);\n  if (parsed.username) {\n    const auth = btoa(\"\".concat(parsed.username, \":\").concat(parsed.password));\n    headers.set('Authorization', \"Basic \".concat(auth));\n    parsed.username = '';\n    parsed.password = '';\n  }\n  url = '' + parsed;\n  for (let k in options.headers) {\n    const name = k.toLowerCase();\n    if (SAFE_HEADERS.has(name) || options.cors && !FORBIDDEN_HEADERS.has(name)) headers.set(k, options.headers[k]);\n  }\n  let opts = {\n    headers,\n    redirect: options.redirect ? 'follow' : 'manual'\n  };\n  if (!options.referrer) opts.referrerPolicy = 'no-referrer';\n  if (options.cors) opts.mode = 'cors';\n  if (options.data) {\n    if (!options.method) opts.method = 'POST';\n    opts.body = options.type === 'json' ? JSON.stringify(options.data) : options.data;\n  }\n  const res = await fetch(url, opts);\n  if (options.expectStatusCode && res.status !== options.expectStatusCode) throw new InvalidStatusCodeError(res.status);\n  const body = detectType(new Uint8Array(await res.arrayBuffer()), options.type);\n  if (options.full) return {\n    headers: Object.fromEntries(res.headers.entries()),\n    status: res.status,\n    body\n  };\n  return body;\n}\nconst IS_NODE = !!(typeof process == 'object' && process.versions && process.versions.node && process.versions.v8);\nfunction fetchUrl(url, options) {\n  const fn = IS_NODE ? fetchNode : fetchBrowser;\n  return fn(url, options);\n}\nexports.default = fetchUrl;","map":{"version":3,"names":["Object","defineProperty","exports","value","InvalidStatusCodeError","InvalidCertError","DEFAULT_OPT","freeze","redirect","expectStatusCode","headers","full","keepAlive","cors","referrer","sslAllowSelfSigned","_redirectCount","Error","constructor","msg","fingerprint256","statusCode","concat","detectType","b","type","text","TextDecoder","fatal","decode","JSON","parse","err","agents","fetchNode","url","_options","options","http","require","https","zlib","promisify","resolve","urlResolve","isSecure","test","opts","method","compactFP","s","replace","toLowerCase","_options$sslPinnedCer","agentOpt","keepAliveMsecs","maxFreeSockets","maxCachedSessions","agentKey","sslPinnedCertificates","map","i","sort","join","agent","Agent","data","body","stringify","rejectUnauthorized","handleRes","res","status","resume","buf","chunk","push","bytes","Buffer","encoding","brotliDecompress","unzip","Promise","reject","_options$sslPinnedCer2","handleError","code","e","req","request","on","error","pinned","mfetchSecureConnect","socket","_socket$getPeerCertif","fp256","getPeerCertificate","isSessionReused","includes","emit","abort","hasListeners","listeners","name","bind","setNoDelay","write","end","SAFE_HEADERS","Set","FORBIDDEN_HEADERS","fetchBrowser","Headers","set","parsed","URL","username","auth","btoa","password","k","has","referrerPolicy","mode","fetch","Uint8Array","arrayBuffer","fromEntries","entries","IS_NODE","process","versions","node","v8","fetchUrl","fn","default"],"sources":["C:/Users/user/Desktop/My Files/MY PROJECTS/finals-blockchain/node_modules/micro-ftch/index.js"],"sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.InvalidStatusCodeError = exports.InvalidCertError = void 0;\nconst DEFAULT_OPT = Object.freeze({\n    redirect: true,\n    expectStatusCode: 200,\n    headers: {},\n    full: false,\n    keepAlive: true,\n    cors: false,\n    referrer: false,\n    sslAllowSelfSigned: false,\n    _redirectCount: 0,\n});\nclass InvalidCertError extends Error {\n    constructor(msg, fingerprint256) {\n        super(msg);\n        this.fingerprint256 = fingerprint256;\n    }\n}\nexports.InvalidCertError = InvalidCertError;\nclass InvalidStatusCodeError extends Error {\n    constructor(statusCode) {\n        super(`Request Failed. Status Code: ${statusCode}`);\n        this.statusCode = statusCode;\n    }\n}\nexports.InvalidStatusCodeError = InvalidStatusCodeError;\nfunction detectType(b, type) {\n    if (!type || type === 'text' || type === 'json') {\n        try {\n            let text = new TextDecoder('utf8', { fatal: true }).decode(b);\n            if (type === 'text')\n                return text;\n            try {\n                return JSON.parse(text);\n            }\n            catch (err) {\n                if (type === 'json')\n                    throw err;\n                return text;\n            }\n        }\n        catch (err) {\n            if (type === 'text' || type === 'json')\n                throw err;\n        }\n    }\n    return b;\n}\nlet agents = {};\nfunction fetchNode(url, _options) {\n    let options = { ...DEFAULT_OPT, ..._options };\n    const http = require('http');\n    const https = require('https');\n    const zlib = require('zlib');\n    const { promisify } = require('util');\n    const { resolve: urlResolve } = require('url');\n    const isSecure = !!/^https/.test(url);\n    let opts = {\n        method: options.method || 'GET',\n        headers: { 'Accept-Encoding': 'gzip, deflate, br' },\n    };\n    const compactFP = (s) => s.replace(/:| /g, '').toLowerCase();\n    if (options.keepAlive) {\n        const agentOpt = {\n            keepAlive: true,\n            keepAliveMsecs: 30 * 1000,\n            maxFreeSockets: 1024,\n            maxCachedSessions: 1024,\n        };\n        const agentKey = [\n            isSecure,\n            isSecure && options.sslPinnedCertificates?.map((i) => compactFP(i)).sort(),\n        ].join();\n        opts.agent =\n            agents[agentKey] || (agents[agentKey] = new (isSecure ? https : http).Agent(agentOpt));\n    }\n    if (options.type === 'json')\n        opts.headers['Content-Type'] = 'application/json';\n    if (options.data) {\n        if (!options.method)\n            opts.method = 'POST';\n        opts.body = options.type === 'json' ? JSON.stringify(options.data) : options.data;\n    }\n    opts.headers = { ...opts.headers, ...options.headers };\n    if (options.sslAllowSelfSigned)\n        opts.rejectUnauthorized = false;\n    const handleRes = async (res) => {\n        const status = res.statusCode;\n        if (options.redirect && 300 <= status && status < 400 && res.headers['location']) {\n            if (options._redirectCount == 10)\n                throw new Error('Request failed. Too much redirects.');\n            options._redirectCount += 1;\n            return await fetchNode(urlResolve(url, res.headers['location']), options);\n        }\n        if (options.expectStatusCode && status !== options.expectStatusCode) {\n            res.resume();\n            throw new InvalidStatusCodeError(status);\n        }\n        let buf = [];\n        for await (const chunk of res)\n            buf.push(chunk);\n        let bytes = Buffer.concat(buf);\n        const encoding = res.headers['content-encoding'];\n        if (encoding === 'br')\n            bytes = await promisify(zlib.brotliDecompress)(bytes);\n        if (encoding === 'gzip' || encoding === 'deflate')\n            bytes = await promisify(zlib.unzip)(bytes);\n        const body = detectType(bytes, options.type);\n        if (options.full)\n            return { headers: res.headers, status, body };\n        return body;\n    };\n    return new Promise((resolve, reject) => {\n        const handleError = async (err) => {\n            if (err && err.code === 'DEPTH_ZERO_SELF_SIGNED_CERT') {\n                try {\n                    await fetchNode(url, { ...options, sslAllowSelfSigned: true, sslPinnedCertificates: [] });\n                }\n                catch (e) {\n                    if (e && e.fingerprint256) {\n                        err = new InvalidCertError(`Self-signed SSL certificate: ${e.fingerprint256}`, e.fingerprint256);\n                    }\n                }\n            }\n            reject(err);\n        };\n        const req = (isSecure ? https : http).request(url, opts, (res) => {\n            res.on('error', handleError);\n            (async () => {\n                try {\n                    resolve(await handleRes(res));\n                }\n                catch (error) {\n                    reject(error);\n                }\n            })();\n        });\n        req.on('error', handleError);\n        const pinned = options.sslPinnedCertificates?.map((i) => compactFP(i));\n        const mfetchSecureConnect = (socket) => {\n            const fp256 = compactFP(socket.getPeerCertificate()?.fingerprint256 || '');\n            if (!fp256 && socket.isSessionReused())\n                return;\n            if (pinned.includes(fp256))\n                return;\n            req.emit('error', new InvalidCertError(`Invalid SSL certificate: ${fp256} Expected: ${pinned}`, fp256));\n            return req.abort();\n        };\n        if (options.sslPinnedCertificates) {\n            req.on('socket', (socket) => {\n                const hasListeners = socket\n                    .listeners('secureConnect')\n                    .map((i) => (i.name || '').replace('bound ', ''))\n                    .includes('mfetchSecureConnect');\n                if (hasListeners)\n                    return;\n                socket.on('secureConnect', mfetchSecureConnect.bind(null, socket));\n            });\n        }\n        if (options.keepAlive)\n            req.setNoDelay(true);\n        if (opts.body)\n            req.write(opts.body);\n        req.end();\n    });\n}\nconst SAFE_HEADERS = new Set(['Accept', 'Accept-Language', 'Content-Language', 'Content-Type'].map((i) => i.toLowerCase()));\nconst FORBIDDEN_HEADERS = new Set(['Accept-Charset', 'Accept-Encoding', 'Access-Control-Request-Headers', 'Access-Control-Request-Method',\n    'Connection', 'Content-Length', 'Cookie', 'Cookie2', 'Date', 'DNT', 'Expect', 'Host', 'Keep-Alive', 'Origin', 'Referer', 'TE', 'Trailer',\n    'Transfer-Encoding', 'Upgrade', 'Via'].map((i) => i.toLowerCase()));\nasync function fetchBrowser(url, _options) {\n    let options = { ...DEFAULT_OPT, ..._options };\n    const headers = new Headers();\n    if (options.type === 'json')\n        headers.set('Content-Type', 'application/json');\n    let parsed = new URL(url);\n    if (parsed.username) {\n        const auth = btoa(`${parsed.username}:${parsed.password}`);\n        headers.set('Authorization', `Basic ${auth}`);\n        parsed.username = '';\n        parsed.password = '';\n    }\n    url = '' + parsed;\n    for (let k in options.headers) {\n        const name = k.toLowerCase();\n        if (SAFE_HEADERS.has(name) || (options.cors && !FORBIDDEN_HEADERS.has(name)))\n            headers.set(k, options.headers[k]);\n    }\n    let opts = { headers, redirect: options.redirect ? 'follow' : 'manual' };\n    if (!options.referrer)\n        opts.referrerPolicy = 'no-referrer';\n    if (options.cors)\n        opts.mode = 'cors';\n    if (options.data) {\n        if (!options.method)\n            opts.method = 'POST';\n        opts.body = options.type === 'json' ? JSON.stringify(options.data) : options.data;\n    }\n    const res = await fetch(url, opts);\n    if (options.expectStatusCode && res.status !== options.expectStatusCode)\n        throw new InvalidStatusCodeError(res.status);\n    const body = detectType(new Uint8Array(await res.arrayBuffer()), options.type);\n    if (options.full)\n        return { headers: Object.fromEntries(res.headers.entries()), status: res.status, body };\n    return body;\n}\nconst IS_NODE = !!(typeof process == 'object' &&\n    process.versions &&\n    process.versions.node &&\n    process.versions.v8);\nfunction fetchUrl(url, options) {\n    const fn = IS_NODE ? fetchNode : fetchBrowser;\n    return fn(url, options);\n}\nexports.default = fetchUrl;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}