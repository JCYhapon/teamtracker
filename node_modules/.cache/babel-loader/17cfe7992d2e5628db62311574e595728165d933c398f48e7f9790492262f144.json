{"ast":null,"code":"\"use strict\";\n\n/**\n * Ported to Typescript from original implementation below:\n * https://github.com/ahultgren/async-eventemitter -- MIT licensed\n *\n * Type Definitions based on work by: patarapolw <https://github.com/patarapolw> -- MIT licensed\n * that was contributed to Definitely Typed below:\n * https://github.com/DefinitelyTyped/DefinitelyTyped/tree/master/types/async-eventemitter\n */\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.AsyncEventEmitter = void 0;\nconst events_1 = require(\"events\");\nasync function runInSeries(context, tasks, data) {\n  let error;\n  for await (const task of tasks) {\n    try {\n      if (task.length < 2) {\n        //sync\n        task.call(context, data);\n      } else {\n        await new Promise((resolve, reject) => {\n          task.call(context, data, error => {\n            if (error) {\n              reject(error);\n            } else {\n              resolve();\n            }\n          });\n        });\n      }\n    } catch (e) {\n      error = e;\n    }\n  }\n  if (error) {\n    throw error;\n  }\n}\nclass AsyncEventEmitter extends events_1.EventEmitter {\n  emit(event) {\n    var _self$_events$event;\n    for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n      args[_key - 1] = arguments[_key];\n    }\n    let [data, callback] = args;\n    const self = this;\n    let listeners = (_self$_events$event = self._events[event]) !== null && _self$_events$event !== void 0 ? _self$_events$event : [];\n    // Optional data argument\n    if (callback === undefined && typeof data === 'function') {\n      callback = data;\n      data = undefined;\n    }\n    // Special treatment of internal newListener and removeListener events\n    if (event === 'newListener' || event === 'removeListener') {\n      data = {\n        event: data,\n        fn: callback\n      };\n      callback = undefined;\n    }\n    // A single listener is just a function not an array...\n    listeners = Array.isArray(listeners) ? listeners : [listeners];\n    runInSeries(self, listeners.slice(), data).then(callback).catch(callback);\n    return self.listenerCount(event) > 0;\n  }\n  once(event, listener) {\n    const self = this;\n    let g;\n    if (typeof listener !== 'function') {\n      throw new TypeError('listener must be a function');\n    }\n    // Hack to support set arity\n    if (listener.length >= 2) {\n      g = function (e, next) {\n        self.removeListener(event, g);\n        void listener(e, next);\n      };\n    } else {\n      g = function (e) {\n        self.removeListener(event, g);\n        void listener(e, g);\n      };\n    }\n    self.on(event, g);\n    return self;\n  }\n  first(event, listener) {\n    var _this$_events$event;\n    let listeners = (_this$_events$event = this._events[event]) !== null && _this$_events$event !== void 0 ? _this$_events$event : [];\n    // Contract\n    if (typeof listener !== 'function') {\n      throw new TypeError('listener must be a function');\n    }\n    // Listeners are not always an array\n    if (!Array.isArray(listeners)) {\n      ;\n      this._events[event] = listeners = [listeners];\n    }\n    listeners.unshift(listener);\n    return this;\n  }\n  before(event, target, listener) {\n    return this.beforeOrAfter(event, target, listener);\n  }\n  after(event, target, listener) {\n    return this.beforeOrAfter(event, target, listener, 'after');\n  }\n  beforeOrAfter(event, target, listener, beforeOrAfter) {\n    var _this$_events$event2;\n    let listeners = (_this$_events$event2 = this._events[event]) !== null && _this$_events$event2 !== void 0 ? _this$_events$event2 : [];\n    let i;\n    let index;\n    const add = beforeOrAfter === 'after' ? 1 : 0;\n    // Contract\n    if (typeof listener !== 'function') {\n      throw new TypeError('listener must be a function');\n    }\n    if (typeof target !== 'function') {\n      throw new TypeError('target must be a function');\n    }\n    // Listeners are not always an array\n    if (!Array.isArray(listeners)) {\n      ;\n      this._events[event] = listeners = [listeners];\n    }\n    index = listeners.length;\n    for (i = listeners.length; i--;) {\n      if (listeners[i] === target) {\n        index = i + add;\n        break;\n      }\n    }\n    listeners.splice(index, 0, listener);\n    return this;\n  }\n  on(event, listener) {\n    return super.on(event, listener);\n  }\n  addListener(event, listener) {\n    return super.addListener(event, listener);\n  }\n  prependListener(event, listener) {\n    return super.prependListener(event, listener);\n  }\n  prependOnceListener(event, listener) {\n    return super.prependOnceListener(event, listener);\n  }\n  removeAllListeners(event) {\n    return super.removeAllListeners(event);\n  }\n  removeListener(event, listener) {\n    return super.removeListener(event, listener);\n  }\n  eventNames() {\n    return super.eventNames();\n  }\n  listeners(event) {\n    return super.listeners(event);\n  }\n  listenerCount(event) {\n    return super.listenerCount(event);\n  }\n  getMaxListeners() {\n    return super.getMaxListeners();\n  }\n  setMaxListeners(maxListeners) {\n    return super.setMaxListeners(maxListeners);\n  }\n}\nexports.AsyncEventEmitter = AsyncEventEmitter;","map":{"version":3,"names":["events_1","require","runInSeries","context","tasks","data","error","task","length","call","Promise","resolve","reject","e","AsyncEventEmitter","EventEmitter","emit","event","_self$_events$event","_len","arguments","args","Array","_key","callback","self","listeners","_events","undefined","fn","isArray","slice","then","catch","listenerCount","once","listener","g","TypeError","next","removeListener","on","first","_this$_events$event","unshift","before","target","beforeOrAfter","after","_this$_events$event2","i","index","add","splice","addListener","prependListener","prependOnceListener","removeAllListeners","eventNames","getMaxListeners","setMaxListeners","maxListeners","exports"],"sources":["E:\\4th Year\\2nd Semester\\BlockChain\\starter-files\\node_modules\\@ethereumjs\\util\\src\\asyncEventEmitter.ts"],"sourcesContent":["/**\n * Ported to Typescript from original implementation below:\n * https://github.com/ahultgren/async-eventemitter -- MIT licensed\n *\n * Type Definitions based on work by: patarapolw <https://github.com/patarapolw> -- MIT licensed\n * that was contributed to Definitely Typed below:\n * https://github.com/DefinitelyTyped/DefinitelyTyped/tree/master/types/async-eventemitter\n */\n\nimport { EventEmitter } from 'events'\ntype AsyncListener<T, R> =\n  | ((data: T, callback?: (result?: R) => void) => Promise<R>)\n  | ((data: T, callback?: (result?: R) => void) => void)\nexport interface EventMap {\n  [event: string]: AsyncListener<any, any>\n}\n\nasync function runInSeries(\n  context: any,\n  tasks: Array<(data: unknown, callback?: (error?: Error) => void) => void>,\n  data: unknown\n): Promise<void> {\n  let error: Error | undefined\n  for await (const task of tasks) {\n    try {\n      if (task.length < 2) {\n        //sync\n        task.call(context, data)\n      } else {\n        await new Promise<void>((resolve, reject) => {\n          task.call(context, data, (error) => {\n            if (error) {\n              reject(error)\n            } else {\n              resolve()\n            }\n          })\n        })\n      }\n    } catch (e: unknown) {\n      error = e as Error\n    }\n  }\n  if (error) {\n    throw error\n  }\n}\n\nexport class AsyncEventEmitter<T extends EventMap> extends EventEmitter {\n  emit<E extends keyof T>(event: E & string, ...args: Parameters<T[E]>) {\n    let [data, callback] = args\n    const self = this\n\n    let listeners = (self as any)._events[event] ?? []\n\n    // Optional data argument\n    if (callback === undefined && typeof data === 'function') {\n      callback = data\n      data = undefined\n    }\n\n    // Special treatment of internal newListener and removeListener events\n    if (event === 'newListener' || event === 'removeListener') {\n      data = {\n        event: data,\n        fn: callback,\n      }\n\n      callback = undefined\n    }\n\n    // A single listener is just a function not an array...\n    listeners = Array.isArray(listeners) ? listeners : [listeners]\n    runInSeries(self, listeners.slice(), data).then(callback).catch(callback)\n\n    return self.listenerCount(event) > 0\n  }\n\n  once<E extends keyof T>(event: E & string, listener: T[E]): this {\n    const self = this\n    let g: (...args: any[]) => void\n\n    if (typeof listener !== 'function') {\n      throw new TypeError('listener must be a function')\n    }\n\n    // Hack to support set arity\n    if (listener.length >= 2) {\n      g = function (e: E, next: any) {\n        self.removeListener(event, g as T[E])\n        void listener(e, next)\n      }\n    } else {\n      g = function (e: E) {\n        self.removeListener(event, g as T[E])\n        void listener(e, g)\n      }\n    }\n\n    self.on(event, g as T[E])\n\n    return self\n  }\n\n  first<E extends keyof T>(event: E & string, listener: T[E]): this {\n    let listeners = (this as any)._events[event] ?? []\n\n    // Contract\n    if (typeof listener !== 'function') {\n      throw new TypeError('listener must be a function')\n    }\n\n    // Listeners are not always an array\n    if (!Array.isArray(listeners)) {\n      ;(this as any)._events[event] = listeners = [listeners]\n    }\n\n    listeners.unshift(listener)\n\n    return this\n  }\n\n  before<E extends keyof T>(event: E & string, target: T[E], listener: T[E]): this {\n    return this.beforeOrAfter(event, target, listener)\n  }\n\n  after<E extends keyof T>(event: E & string, target: T[E], listener: T[E]): this {\n    return this.beforeOrAfter(event, target, listener, 'after')\n  }\n\n  private beforeOrAfter<E extends keyof T>(\n    event: E & string,\n    target: T[E],\n    listener: T[E],\n    beforeOrAfter?: string\n  ) {\n    let listeners = (this as any)._events[event] ?? []\n    let i\n    let index\n    const add = beforeOrAfter === 'after' ? 1 : 0\n\n    // Contract\n    if (typeof listener !== 'function') {\n      throw new TypeError('listener must be a function')\n    }\n    if (typeof target !== 'function') {\n      throw new TypeError('target must be a function')\n    }\n\n    // Listeners are not always an array\n    if (!Array.isArray(listeners)) {\n      ;(this as any)._events[event] = listeners = [listeners]\n    }\n\n    index = listeners.length\n\n    for (i = listeners.length; i--; ) {\n      if (listeners[i] === target) {\n        index = i + add\n        break\n      }\n    }\n\n    listeners.splice(index, 0, listener)\n\n    return this\n  }\n\n  on<E extends keyof T>(event: E & string, listener: T[E]): this {\n    return super.on(event, listener)\n  }\n\n  addListener<E extends keyof T>(event: E & string, listener: T[E]): this {\n    return super.addListener(event, listener)\n  }\n\n  prependListener<E extends keyof T>(event: E & string, listener: T[E]): this {\n    return super.prependListener(event, listener)\n  }\n\n  prependOnceListener<E extends keyof T>(event: E & string, listener: T[E]): this {\n    return super.prependOnceListener(event, listener)\n  }\n\n  removeAllListeners(event?: keyof T & string): this {\n    return super.removeAllListeners(event)\n  }\n\n  removeListener<E extends keyof T>(event: E & string, listener: T[E]): this {\n    return super.removeListener(event, listener)\n  }\n\n  eventNames(): Array<keyof T & string> {\n    return super.eventNames() as keyof T & string[]\n  }\n\n  listeners<E extends keyof T>(event: E & string): Array<T[E]> {\n    return super.listeners(event) as T[E][]\n  }\n\n  listenerCount(event: keyof T & string): number {\n    return super.listenerCount(event)\n  }\n\n  getMaxListeners(): number {\n    return super.getMaxListeners()\n  }\n\n  setMaxListeners(maxListeners: number): this {\n    return super.setMaxListeners(maxListeners)\n  }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}